pub mod challenge_tag {
    //! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1
    use sea_orm::entity::prelude::*;
    use serde::{Deserialize, Serialize};
    #[sea_orm(table_name = "challenge_tag")]
    #[schema(as = ChallengeTagModel)]
    #[oxide(table(name = "ChallengeTag"))]
    pub struct Model {
        pub created_at: DateTime,
        pub updated_at: DateTime,
        #[sea_orm(primary_key, auto_increment = false)]
        pub challenge_id: Uuid,
        #[sea_orm(primary_key, auto_increment = false)]
        pub tag_id: Uuid,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Model {
        #[inline]
        fn clone(&self) -> Model {
            Model {
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                challenge_id: ::core::clone::Clone::clone(&self.challenge_id),
                tag_id: ::core::clone::Clone::clone(&self.tag_id),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Model {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Model",
                "created_at",
                &self.created_at,
                "updated_at",
                &self.updated_at,
                "challenge_id",
                &self.challenge_id,
                "tag_id",
                &&self.tag_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Model {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Model {
        #[inline]
        fn eq(&self, other: &Model) -> bool {
            self.created_at == other.created_at && self.updated_at == other.updated_at
                && self.challenge_id == other.challenge_id && self.tag_id == other.tag_id
        }
    }
    /// Generated by sea-orm-macros
    pub enum Column {
        /// Generated by sea-orm-macros
        CreatedAt,
        /// Generated by sea-orm-macros
        UpdatedAt,
        /// Generated by sea-orm-macros
        ChallengeId,
        /// Generated by sea-orm-macros
        TagId,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Column {}
    #[automatically_derived]
    impl ::core::clone::Clone for Column {
        #[inline]
        fn clone(&self) -> Column {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Column {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Column::CreatedAt => "CreatedAt",
                    Column::UpdatedAt => "UpdatedAt",
                    Column::ChallengeId => "ChallengeId",
                    Column::TagId => "TagId",
                },
            )
        }
    }
    ///An iterator over the variants of [Column]
    #[allow(missing_copy_implementations)]
    pub struct ColumnIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for ColumnIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ColumnIter").field("len", &self.len()).finish()
        }
    }
    impl ColumnIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Column> {
            match idx {
                0usize => ::core::option::Option::Some(Column::CreatedAt),
                1usize => ::core::option::Option::Some(Column::UpdatedAt),
                2usize => ::core::option::Option::Some(Column::ChallengeId),
                3usize => ::core::option::Option::Some(Column::TagId),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Column {
        type Iterator = ColumnIter;
        fn iter() -> ColumnIter {
            ColumnIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for ColumnIter {
        type Item = Column;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 4usize {
                0
            } else {
                4usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 4usize {
                self.idx = 4usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                ColumnIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for ColumnIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for ColumnIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 4usize {
                self.back_idx = 4usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                ColumnIter::get(self, 4usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for ColumnIter {}
    impl Clone for ColumnIter {
        fn clone(&self) -> ColumnIter {
            ColumnIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl Column {
        fn default_as_str(&self) -> &str {
            match self {
                Self::CreatedAt => "created_at",
                Self::UpdatedAt => "updated_at",
                Self::ChallengeId => "challenge_id",
                Self::TagId => "tag_id",
            }
        }
    }
    #[automatically_derived]
    impl std::str::FromStr for Column {
        type Err = sea_orm::ColumnFromStrErr;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "created_at" | "createdAt" => Ok(Column::CreatedAt),
                "updated_at" | "updatedAt" => Ok(Column::UpdatedAt),
                "challenge_id" | "challengeId" => Ok(Column::ChallengeId),
                "tag_id" | "tagId" => Ok(Column::TagId),
                _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for Column {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Column {
        fn as_str(&self) -> &str {
            self.default_as_str()
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::ColumnTrait for Column {
        type EntityName = Entity;
        fn def(&self) -> sea_orm::prelude::ColumnDef {
            match self {
                Self::CreatedAt => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::DateTime,
                    )
                }
                Self::UpdatedAt => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::DateTime,
                    )
                }
                Self::ChallengeId => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Uuid,
                    )
                }
                Self::TagId => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Uuid,
                    )
                }
            }
        }
        fn select_as(
            &self,
            expr: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
            }
        }
        fn save_as(
            &self,
            val: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct Entity;
    #[automatically_derived]
    impl ::core::marker::Copy for Entity {}
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Entity {
        #[inline]
        fn default() -> Entity {
            Entity {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Entity")
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::EntityTrait for Entity {
        type Model = Model;
        type ActiveModel = ActiveModel;
        type Column = Column;
        type PrimaryKey = PrimaryKey;
        type Relation = Relation;
    }
    #[automatically_derived]
    impl sea_orm::Iden for Entity {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Entity {
        fn as_str(&self) -> &str {
            <Self as sea_orm::EntityName>::table_name(self)
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::EntityName for Entity {
        fn schema_name(&self) -> Option<&str> {
            None
        }
        fn table_name(&self) -> &str {
            "challenge_tag"
        }
        fn comment(&self) -> Option<&str> {
            None
        }
    }
    /// Generated by sea-orm-macros
    pub enum PrimaryKey {
        /// Generated by sea-orm-macros
        ChallengeId,
        /// Generated by sea-orm-macros
        TagId,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrimaryKey {}
    #[automatically_derived]
    impl ::core::clone::Clone for PrimaryKey {
        #[inline]
        fn clone(&self) -> PrimaryKey {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrimaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PrimaryKey::ChallengeId => "ChallengeId",
                    PrimaryKey::TagId => "TagId",
                },
            )
        }
    }
    ///An iterator over the variants of [PrimaryKey]
    #[allow(missing_copy_implementations)]
    pub struct PrimaryKeyIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for PrimaryKeyIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
        }
    }
    impl PrimaryKeyIter {
        fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
            match idx {
                0usize => ::core::option::Option::Some(PrimaryKey::ChallengeId),
                1usize => ::core::option::Option::Some(PrimaryKey::TagId),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
        type Iterator = PrimaryKeyIter;
        fn iter() -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for PrimaryKeyIter {
        type Item = PrimaryKey;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 2usize {
                0
            } else {
                2usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 2usize {
                self.idx = 2usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                PrimaryKeyIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for PrimaryKeyIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for PrimaryKeyIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 2usize {
                self.back_idx = 2usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                PrimaryKeyIter::get(self, 2usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for PrimaryKeyIter {}
    impl Clone for PrimaryKeyIter {
        fn clone(&self) -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for PrimaryKey {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for PrimaryKey {
        fn as_str(&self) -> &str {
            match self {
                Self::ChallengeId => "challenge_id",
                Self::TagId => "tag_id",
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
        type Column = Column;
        fn into_column(self) -> Self::Column {
            match self {
                Self::ChallengeId => Self::Column::ChallengeId,
                Self::TagId => Self::Column::TagId,
            }
        }
        fn from_column(col: Self::Column) -> Option<Self> {
            match col {
                Self::Column::ChallengeId => Some(Self::ChallengeId),
                Self::Column::TagId => Some(Self::TagId),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl PrimaryKeyTrait for PrimaryKey {
        type ValueType = (Uuid, Uuid);
        fn auto_increment() -> bool {
            false
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for Model {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                created_at: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt,
                            )
                            .into(),
                    )?,
                updated_at: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt,
                            )
                            .into(),
                    )?,
                challenge_id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::ChallengeId,
                            )
                            .into(),
                    )?,
                tag_id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TagId,
                            )
                            .into(),
                    )?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::ModelTrait for Model {
        type Entity = Entity;
        fn get(
            &self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        ) -> sea_orm::Value {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt => {
                    self.created_at.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagId => {
                    self.tag_id.clone().into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt => {
                    self.created_at = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagId => {
                    self.tag_id = v.unwrap();
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct ActiveModel {
        /// Generated by sea-orm-macros
        pub created_at: sea_orm::ActiveValue<DateTime>,
        /// Generated by sea-orm-macros
        pub updated_at: sea_orm::ActiveValue<DateTime>,
        /// Generated by sea-orm-macros
        pub challenge_id: sea_orm::ActiveValue<Uuid>,
        /// Generated by sea-orm-macros
        pub tag_id: sea_orm::ActiveValue<Uuid>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActiveModel {
        #[inline]
        fn clone(&self) -> ActiveModel {
            ActiveModel {
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                challenge_id: ::core::clone::Clone::clone(&self.challenge_id),
                tag_id: ::core::clone::Clone::clone(&self.tag_id),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActiveModel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ActiveModel",
                "created_at",
                &self.created_at,
                "updated_at",
                &self.updated_at,
                "challenge_id",
                &self.challenge_id,
                "tag_id",
                &&self.tag_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ActiveModel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ActiveModel {
        #[inline]
        fn eq(&self, other: &ActiveModel) -> bool {
            self.created_at == other.created_at && self.updated_at == other.updated_at
                && self.challenge_id == other.challenge_id && self.tag_id == other.tag_id
        }
    }
    #[automatically_derived]
    impl std::default::Default for ActiveModel {
        fn default() -> Self {
            <Self as sea_orm::ActiveModelBehavior>::new()
        }
    }
    #[automatically_derived]
    impl std::convert::From<Model> for ActiveModel {
        fn from(m: Model) -> Self {
            Self {
                created_at: sea_orm::ActiveValue::unchanged(m.created_at),
                updated_at: sea_orm::ActiveValue::unchanged(m.updated_at),
                challenge_id: sea_orm::ActiveValue::unchanged(m.challenge_id),
                tag_id: sea_orm::ActiveValue::unchanged(m.tag_id),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::IntoActiveModel<ActiveModel> for Model {
        fn into_active_model(self) -> ActiveModel {
            self.into()
        }
    }
    #[automatically_derived]
    impl sea_orm::ActiveModelTrait for ActiveModel {
        type Entity = Entity;
        fn take(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.created_at);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.updated_at);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.challenge_id);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.tag_id);
                    value.into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn get(
            &self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    self.tag_id.clone().into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    self.tag_id = sea_orm::ActiveValue::set(v.unwrap());
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
        fn not_set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    self.tag_id = sea_orm::ActiveValue::not_set();
                }
                _ => {}
            }
        }
        fn is_not_set(&self, c: <Self::Entity as sea_orm::EntityTrait>::Column) -> bool {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    self.tag_id.is_not_set()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
        fn default() -> Self {
            Self {
                created_at: sea_orm::ActiveValue::not_set(),
                updated_at: sea_orm::ActiveValue::not_set(),
                challenge_id: sea_orm::ActiveValue::not_set(),
                tag_id: sea_orm::ActiveValue::not_set(),
            }
        }
        fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::ChallengeId => {
                    self.challenge_id.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::TagId => {
                    self.tag_id.reset()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
    }
    #[automatically_derived]
    impl std::convert::TryFrom<ActiveModel> for Model {
        type Error = sea_orm::DbErr;
        fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
            if match a.created_at {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("created_at".to_owned()));
            }
            if match a.updated_at {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("updated_at".to_owned()));
            }
            if match a.challenge_id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("challenge_id".to_owned()));
            }
            if match a.tag_id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("tag_id".to_owned()));
            }
            Ok(Self {
                created_at: a.created_at.into_value().unwrap().unwrap(),
                updated_at: a.updated_at.into_value().unwrap().unwrap(),
                challenge_id: a.challenge_id.into_value().unwrap().unwrap(),
                tag_id: a.tag_id.into_value().unwrap().unwrap(),
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::TryIntoModel<Model> for ActiveModel {
        fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
            self.try_into()
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Model {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<DateTime>;
            let _: ::core::cmp::AssertParamIsEq<Uuid>;
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Model {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Model",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "challenge_id",
                    &self.challenge_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag_id",
                    &self.tag_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Model {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "created_at" => _serde::__private::Ok(__Field::__field0),
                            "updated_at" => _serde::__private::Ok(__Field::__field1),
                            "challenge_id" => _serde::__private::Ok(__Field::__field2),
                            "tag_id" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"created_at" => _serde::__private::Ok(__Field::__field0),
                            b"updated_at" => _serde::__private::Ok(__Field::__field1),
                            b"challenge_id" => _serde::__private::Ok(__Field::__field2),
                            b"tag_id" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Model>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Model;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Model",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            DateTime,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Model with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            DateTime,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Model with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Uuid,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Model with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Uuid,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Model with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Model {
                            created_at: __field0,
                            updated_at: __field1,
                            challenge_id: __field2,
                            tag_id: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<DateTime> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<DateTime> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Uuid> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Uuid> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "challenge_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag_id"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("challenge_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag_id")?
                            }
                        };
                        _serde::__private::Ok(Model {
                            created_at: __field0,
                            updated_at: __field1,
                            challenge_id: __field2,
                            tag_id: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "created_at",
                    "updated_at",
                    "challenge_id",
                    "tag_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Model",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Model>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl utoipa::__dev::ComposeSchema for Model {
        fn compose(
            mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
        ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
            {
                let mut object = utoipa::openapi::ObjectBuilder::new();
                object = object
                    .property(
                        "created_at",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::DateTime,
                                    ),
                                ),
                            ),
                    )
                    .required("created_at");
                object = object
                    .property(
                        "updated_at",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::DateTime,
                                    ),
                                ),
                            ),
                    )
                    .required("updated_at");
                object = object
                    .property(
                        "challenge_id",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::Uuid,
                                    ),
                                ),
                            ),
                    )
                    .required("challenge_id");
                object = object
                    .property(
                        "tag_id",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::Uuid,
                                    ),
                                ),
                            ),
                    )
                    .required("tag_id");
                object
            }
                .into()
        }
    }
    impl utoipa::ToSchema for Model {
        fn name() -> std::borrow::Cow<'static, str> {
            std::borrow::Cow::Borrowed("ChallengeTagModel")
        }
        fn schemas(
            schemas: &mut Vec<
                (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
            >,
        ) {
            schemas.extend([]);
        }
    }
    #[sea_orm(entity = "Entity")]
    pub struct CreateChallengeTagSchema {
        pub challenge_id: Uuid,
        pub tag_id: Uuid,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CreateChallengeTagSchema {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "CreateChallengeTagSchema",
                "challenge_id",
                &self.challenge_id,
                "tag_id",
                &&self.tag_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CreateChallengeTagSchema {
        #[inline]
        fn clone(&self) -> CreateChallengeTagSchema {
            CreateChallengeTagSchema {
                challenge_id: ::core::clone::Clone::clone(&self.challenge_id),
                tag_id: ::core::clone::Clone::clone(&self.tag_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CreateChallengeTagSchema {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CreateChallengeTagSchema",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "challenge_id",
                    &self.challenge_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag_id",
                    &self.tag_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CreateChallengeTagSchema {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "challenge_id" => _serde::__private::Ok(__Field::__field0),
                            "tag_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"challenge_id" => _serde::__private::Ok(__Field::__field0),
                            b"tag_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CreateChallengeTagSchema>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CreateChallengeTagSchema;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CreateChallengeTagSchema",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Uuid,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CreateChallengeTagSchema with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Uuid,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CreateChallengeTagSchema with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(CreateChallengeTagSchema {
                            challenge_id: __field0,
                            tag_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Uuid> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Uuid> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "challenge_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag_id"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Uuid>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("challenge_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag_id")?
                            }
                        };
                        _serde::__private::Ok(CreateChallengeTagSchema {
                            challenge_id: __field0,
                            tag_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["challenge_id", "tag_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CreateChallengeTagSchema",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            CreateChallengeTagSchema,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl utoipa::__dev::ComposeSchema for CreateChallengeTagSchema {
        fn compose(
            mut generics: Vec<utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>>,
        ) -> utoipa::openapi::RefOr<utoipa::openapi::schema::Schema> {
            {
                let mut object = utoipa::openapi::ObjectBuilder::new();
                object = object
                    .property(
                        "challenge_id",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::Uuid,
                                    ),
                                ),
                            ),
                    )
                    .required("challenge_id");
                object = object
                    .property(
                        "tag_id",
                        utoipa::openapi::ObjectBuilder::new()
                            .schema_type(
                                utoipa::openapi::schema::SchemaType::new(
                                    utoipa::openapi::schema::Type::String,
                                ),
                            )
                            .format(
                                Some(
                                    utoipa::openapi::schema::SchemaFormat::KnownFormat(
                                        utoipa::openapi::schema::KnownFormat::Uuid,
                                    ),
                                ),
                            ),
                    )
                    .required("tag_id");
                object
            }
                .into()
        }
    }
    impl utoipa::ToSchema for CreateChallengeTagSchema {
        fn name() -> std::borrow::Cow<'static, str> {
            std::borrow::Cow::Borrowed("CreateChallengeTagSchema")
        }
        fn schemas(
            schemas: &mut Vec<
                (String, utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>),
            >,
        ) {
            schemas.extend([]);
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for CreateChallengeTagSchema {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                challenge_id: row.try_get(pre, "challenge_id")?,
                tag_id: row.try_get(pre, "tag_id")?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::PartialModelTrait for CreateChallengeTagSchema {
        fn select_cols<S: sea_orm::SelectColumns>(select: S) -> S {
            let select = sea_orm::SelectColumns::select_column(
                select,
                <Entity as sea_orm::EntityTrait>::Column::ChallengeId,
            );
            let select = sea_orm::SelectColumns::select_column(
                select,
                <Entity as sea_orm::EntityTrait>::Column::TagId,
            );
            select
        }
    }
    impl sea_orm::IntoActiveModel<ActiveModel> for CreateChallengeTagSchema {
        fn into_active_model(self) -> ActiveModel {
            ActiveModel {
                created_at: sea_orm::ActiveValue::NotSet,
                updated_at: sea_orm::ActiveValue::Set(chrono::Utc::now().naive_utc()),
                challenge_id: sea_orm::ActiveValue::Set(self.challenge_id),
                tag_id: sea_orm::ActiveValue::Set(self.tag_id),
            }
        }
    }
    pub enum Relation {
        #[sea_orm(
            belongs_to = "super::challenge::Entity",
            from = "Column::ChallengeId",
            to = "super::challenge::Column::Id",
            on_update = "Cascade",
            on_delete = "Cascade"
        )]
        Challenge,
        #[sea_orm(
            belongs_to = "super::tag::Entity",
            from = "Column::TagId",
            to = "super::tag::Column::Id",
            on_update = "Cascade",
            on_delete = "Cascade"
        )]
        Tag,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Relation {}
    #[automatically_derived]
    impl ::core::clone::Clone for Relation {
        #[inline]
        fn clone(&self) -> Relation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Relation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Relation::Challenge => "Challenge",
                    Relation::Tag => "Tag",
                },
            )
        }
    }
    ///An iterator over the variants of [Relation]
    #[allow(missing_copy_implementations)]
    pub struct RelationIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for RelationIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RelationIter").field("len", &self.len()).finish()
        }
    }
    impl RelationIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
            match idx {
                0usize => ::core::option::Option::Some(Relation::Challenge),
                1usize => ::core::option::Option::Some(Relation::Tag),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Relation {
        type Iterator = RelationIter;
        fn iter() -> RelationIter {
            RelationIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for RelationIter {
        type Item = Relation;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 2usize {
                0
            } else {
                2usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 2usize {
                self.idx = 2usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                RelationIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for RelationIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for RelationIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 2usize {
                self.back_idx = 2usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                RelationIter::get(self, 2usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for RelationIter {}
    impl Clone for RelationIter {
        fn clone(&self) -> RelationIter {
            RelationIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::RelationTrait for Relation {
        fn def(&self) -> sea_orm::entity::RelationDef {
            match self {
                Self::Challenge => {
                    Entity::belongs_to(super::challenge::Entity)
                        .from(Column::ChallengeId)
                        .to(super::challenge::Column::Id)
                        .on_update(sea_orm::prelude::ForeignKeyAction::Cascade)
                        .on_delete(sea_orm::prelude::ForeignKeyAction::Cascade)
                        .into()
                }
                Self::Tag => {
                    Entity::belongs_to(super::tag::Entity)
                        .from(Column::TagId)
                        .to(super::tag::Column::Id)
                        .on_update(sea_orm::prelude::ForeignKeyAction::Cascade)
                        .on_delete(sea_orm::prelude::ForeignKeyAction::Cascade)
                        .into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("No RelationDef for Relation"),
                    );
                }
            }
        }
    }
    impl Related<super::challenge::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Challenge.def()
        }
    }
    impl Related<super::tag::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Tag.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
